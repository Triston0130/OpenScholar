import { Paper } from '../types';

export type CitationStyle = 'apa' | 'mla' | 'chicago';

export interface FormattedCitation {
  citation: string;
  style: CitationStyle;
  paper: Paper;
}

/**
 * Generate a formatted citation for a single paper
 */
export const formatCitation = (paper: Paper, style: CitationStyle): string => {
  switch (style) {
    case 'apa':
      return formatAPA(paper);
    case 'mla':
      return formatMLA(paper);
    case 'chicago':
      return formatChicago(paper);
    default:
      return formatAPA(paper);
  }
};

/**
 * Generate multiple citations for papers
 */
export const formatCitations = (papers: Paper[], style: CitationStyle): FormattedCitation[] => {
  return papers.map(paper => ({
    citation: formatCitation(paper, style),
    style,
    paper
  }));
};

/**
 * Export citations as formatted text
 */
export const exportCitations = (papers: Paper[], style: CitationStyle, collectionName?: string): string => {
  const citations = formatCitations(papers, style);
  const styleNames = {
    apa: 'APA (7th Edition)',
    mla: 'MLA (9th Edition)', 
    chicago: 'Chicago (17th Edition)'
  };

  const header = collectionName 
    ? `# ${collectionName} - ${styleNames[style]} Citations\n\n`
    : `# ${styleNames[style]} Citations\n\n`;

  // APA style doesn't use numbered lists - use alphabetical hanging indent format
  let citationList: string;
  if (style === 'apa') {
    // Sort alphabetically by first author's last name for APA
    const sortedCitations = citations.sort((a, b) => {
      const firstAuthorA = a.paper.authors[0] || '';
      const firstAuthorB = b.paper.authors[0] || '';
      return firstAuthorA.localeCompare(firstAuthorB);
    });
    citationList = sortedCitations.map(item => item.citation).join('\n\n');
  } else {
    // Other styles can use numbered lists
    citationList = citations.map((item, index) => 
      `${index + 1}. ${item.citation}`
    ).join('\n\n');
  }

  const footer = `\n\n---\n*Generated by OpenScholar on ${new Date().toLocaleDateString()}*\n*${papers.length} citations in ${styleNames[style]} format*`;

  return header + citationList + footer;
};

/**
 * Format citation in APA style (7th edition)
 */
const formatAPA = (paper: Paper): string => {
  const authors = formatAuthorsAPA(paper.authors);
  const year = paper.year ? `(${paper.year})` : '(n.d.)';
  
  // Format title - sentence case for articles, no quotes
  let title = toSentenceCase(paper.title.trim());
  if (!title.endsWith('.') && !title.endsWith('?') && !title.endsWith('!')) {
    title += '.';
  }
  
  let citation = `${authors} ${year}. ${title}`;
  
  // Add journal information if available
  if (paper.journal) {
    // Journal name should be italicized and in title case
    const journalName = toTitleCase(paper.journal);
    citation += ` *${journalName}*`;
    
    // Note: In a complete implementation, we would add:
    // - Volume number (italicized)
    // - Issue number in parentheses
    // - Page numbers
    // Format: Journal Name, Volume(Issue), pages.
    citation += '.';
  }
  
  // Add DOI (preferred) or URL
  if (paper.doi) {
    citation += ` https://doi.org/${paper.doi}`;
  } else if (paper.full_text_url) {
    citation += ` ${paper.full_text_url}`;
  }
  
  return citation;
};

/**
 * Format citation in MLA style (9th edition)
 */
const formatMLA = (paper: Paper): string => {
  const authors = formatAuthorsMLA(paper.authors);
  const title = `"${paper.title.replace(/\.$/, '')}"`;
  
  let citation = `${authors}. ${title}`;
  
  if (paper.journal) {
    citation += ` *${paper.journal}*,`;
  }
  
  if (paper.year) {
    citation += ` ${paper.year},`;
  }
  
  if (paper.doi) {
    citation += ` doi:${paper.doi}.`;
  } else if (paper.full_text_url) {
    const domain = extractDomain(paper.full_text_url);
    citation += ` *${domain}*, ${paper.full_text_url}.`;
  } else {
    citation = citation.replace(/,$/, '.');
  }
  
  return citation;
};

/**
 * Format citation in Chicago style (17th edition, Author-Date)
 */
const formatChicago = (paper: Paper): string => {
  const authors = formatAuthorsChicago(paper.authors);
  const year = paper.year || 'n.d.';
  const title = `"${paper.title.replace(/\.$/, '')}"`;
  
  let citation = `${authors}. ${year}. ${title}.`;
  
  if (paper.journal) {
    citation += ` *${paper.journal}*.`;
  }
  
  if (paper.doi) {
    citation += ` https://doi.org/${paper.doi}.`;
  } else if (paper.full_text_url) {
    citation += ` ${paper.full_text_url}.`;
  }
  
  return citation;
};

/**
 * Format authors for APA style
 */
const formatAuthorsAPA = (authors: string[]): string => {
  if (authors.length === 0) return '[No author]';
  if (authors.length === 1) return formatAuthorLastFirst(authors[0]);
  if (authors.length === 2) {
    return `${formatAuthorLastFirst(authors[0])}, & ${formatAuthorLastFirst(authors[1])}`;
  }
  if (authors.length <= 20) {
    const formatted = authors.slice(0, -1).map(formatAuthorLastFirst).join(', ');
    return `${formatted}, & ${formatAuthorLastFirst(authors[authors.length - 1])}`;
  }
  // 21+ authors: first 19, then "...", then last author
  const first19 = authors.slice(0, 19).map(formatAuthorLastFirst).join(', ');
  return `${first19}, ... ${formatAuthorLastFirst(authors[authors.length - 1])}`;
};

/**
 * Format authors for MLA style
 */
const formatAuthorsMLA = (authors: string[]): string => {
  if (authors.length === 0) return '[No author]';
  if (authors.length === 1) return formatAuthorLastFirst(authors[0]);
  if (authors.length === 2) {
    return `${formatAuthorLastFirst(authors[0])}, and ${formatAuthorFirstLast(authors[1])}`;
  }
  if (authors.length === 3) {
    return `${formatAuthorLastFirst(authors[0])}, ${formatAuthorFirstLast(authors[1])}, and ${formatAuthorFirstLast(authors[2])}`;
  }
  // 4+ authors: first author only, then "et al."
  return `${formatAuthorLastFirst(authors[0])}, et al.`;
};

/**
 * Format authors for Chicago style
 */
const formatAuthorsChicago = (authors: string[]): string => {
  if (authors.length === 0) return '[No author]';
  if (authors.length === 1) return formatAuthorLastFirst(authors[0]);
  if (authors.length === 2) {
    return `${formatAuthorLastFirst(authors[0])}, and ${formatAuthorFirstLast(authors[1])}`;
  }
  if (authors.length === 3) {
    return `${formatAuthorLastFirst(authors[0])}, ${formatAuthorFirstLast(authors[1])}, and ${formatAuthorFirstLast(authors[2])}`;
  }
  if (authors.length <= 10) {
    const allButLast = authors.slice(0, -1).map((author, index) => 
      index === 0 ? formatAuthorLastFirst(author) : formatAuthorFirstLast(author)
    ).join(', ');
    return `${allButLast}, and ${formatAuthorFirstLast(authors[authors.length - 1])}`;
  }
  // 11+ authors: first 7, then "et al."
  const first7 = authors.slice(0, 7).map((author, index) => 
    index === 0 ? formatAuthorLastFirst(author) : formatAuthorFirstLast(author)
  ).join(', ');
  return `${first7}, et al.`;
};

/**
 * Format author name as "Last, F. M." (APA style with initials)
 */
const formatAuthorLastFirst = (author: string): string => {
  const cleaned = author.trim().replace(/,$/, '');
  
  // If already in "Last, First" format
  if (cleaned.includes(',')) {
    const parts = cleaned.split(',').map(part => part.trim());
    const lastName = parts[0];
    const firstPart = parts[1] || '';
    
    // If firstPart looks like initials already (e.g., "J. M." or "JM")
    if (/^[A-Z]\.?\s*[A-Z]?\.?$/.test(firstPart)) {
      // Ensure proper formatting with periods and spaces
      const initials = firstPart.replace(/([A-Z])\.?/g, '$1.').replace(/\.\./g, '.').trim();
      return `${lastName}, ${initials}`;
    }
    
    // Otherwise convert full names to initials
    const initials = convertToInitials(firstPart);
    return `${lastName}, ${initials}`;
  }
  
  // Handle various name formats
  const parts = cleaned.split(' ');
  if (parts.length === 1) return parts[0];
  
  // Special case: Handle formats like "AS Vignesh" where AS are consecutive initials without spaces
  if (parts.length === 2 && /^[A-Z]{2,}$/.test(parts[0])) {
    // First part is multiple initials, second is last name
    const initials = parts[0].split('').map(letter => letter + '.').join(' ');
    return `${parts[1]}, ${initials}`;
  }
  
  // Special case: Handle single initial like "J Smith" or "J. Smith" format
  if (parts.length === 2 && /^[A-Z]\.?$/.test(parts[0])) {
    const initial = parts[0].charAt(0) + '.';
    return `${parts[1]}, ${initial}`;
  }
  
  // For two-part names where first part is a full name (not just initials)
  // This handles cases like "Bonaz B" where Bonaz is first name, B is last name
  if (parts.length === 2 && parts[0].length > 1 && /^[A-Z][a-z]/.test(parts[0])) {
    // Check if second part looks like a single letter (likely last name initial that got cut off)
    if (parts[1].length === 1) {
      // This is ambiguous - could be "FirstName LastInitial" or "FirstName LastName"
      // In academic contexts, single letters are usually last names (e.g., "Bonaz B" means B is the last name)
      const firstInitial = parts[0].charAt(0) + '.';
      return `${parts[1]}, ${firstInitial}`;
    }
  }
  
  // For multi-word names, check if it looks like "First Middle Last" or "First Last"
  // Common patterns:
  // 1. "John Smith" -> "Smith, J."
  // 2. "John Michael Smith" -> "Smith, J. M."
  // 3. "van der Waals" -> keep as compound last name
  // 4. "de la Cruz" -> keep as compound last name
  
  // Check for compound last names (von, van, de, la, etc.)
  const compoundPrefixes = ['von', 'van', 'der', 'de', 'la', 'del', 'di', 'da', 'le'];
  let lastNameStartIndex = parts.length - 1;
  
  // Work backwards to find compound last names
  for (let i = parts.length - 2; i >= 0; i--) {
    if (compoundPrefixes.includes(parts[i].toLowerCase())) {
      lastNameStartIndex = i;
    } else {
      break;
    }
  }
  
  // If we found a compound last name
  if (lastNameStartIndex < parts.length - 1) {
    const lastName = parts.slice(lastNameStartIndex).join(' ');
    const firstNames = parts.slice(0, lastNameStartIndex);
    const initials = firstNames.map(name => name.charAt(0).toUpperCase() + '.').join(' ');
    return `${lastName}, ${initials}`;
  }
  
  // Standard format: assume last word is surname
  const lastName = parts[parts.length - 1];
  const firstNames = parts.slice(0, -1);
  const initials = firstNames.map(name => name.charAt(0).toUpperCase() + '.').join(' ');
  
  return `${lastName}, ${initials}`;
};

/**
 * Format author name as "First Middle Last"
 */
const formatAuthorFirstLast = (author: string): string => {
  const cleaned = author.trim().replace(/,$/, '');
  
  // If in "Last, First" format, convert to "First Last"
  if (cleaned.includes(',')) {
    const [lastName, firstNames] = cleaned.split(',').map(part => part.trim());
    return `${firstNames} ${lastName}`;
  }
  
  // Already in "First Last" format
  return cleaned;
};

/**
 * Extract domain from URL for MLA citations
 */
const extractDomain = (url: string): string => {
  try {
    const domain = new URL(url).hostname.replace('www.', '');
    // Capitalize first letter
    return domain.charAt(0).toUpperCase() + domain.slice(1);
  } catch {
    return 'Web';
  }
};

/**
 * Get citation style display names
 */
export const getCitationStyleName = (style: CitationStyle): string => {
  const names = {
    apa: 'APA (7th Edition)',
    mla: 'MLA (9th Edition)',
    chicago: 'Chicago (17th Edition)'
  };
  return names[style];
};

/**
 * Convert a name to initials with periods (e.g., "John Michael" -> "J. M.")
 */
const convertToInitials = (name: string): string => {
  return name.split(' ')
    .filter(part => part.length > 0)
    .map(part => part.charAt(0).toUpperCase() + '.')
    .join(' ');
};

/**
 * Convert text to sentence case (first letter capitalized, rest lowercase except proper nouns)
 */
const toSentenceCase = (text: string): string => {
  if (!text) return text;
  
  // APA style: Only the first word of the title, the first word after a colon or em dash,
  // and proper nouns are capitalized
  let result = text.toLowerCase();
  
  // Capitalize first character
  result = result.charAt(0).toUpperCase() + result.slice(1);
  
  // Capitalize first letter after colon or em dash
  result = result.replace(/([:—]\s+)([a-z])/g, (match, separator, letter) => 
    separator + letter.toUpperCase()
  );
  
  // Keep acronyms in uppercase (e.g., COVID, AI, DNA)
  result = result.replace(/\b([a-z]{2,5})\b/g, (match) => {
    const upper = match.toUpperCase();
    // Common acronyms to preserve
    const acronyms = ['COVID', 'AIDS', 'DNA', 'RNA', 'MRI', 'CT', 'AI', 'ML', 'NLP', 'USA', 'UK', 'EU', 'WHO', 'CDC', 'FDA', 'NIH', 'IEEE', 'ACM'];
    return acronyms.includes(upper) ? upper : match;
  });
  
  return result;
};

/**
 * Convert text to title case (capitalize first letter of each major word)
 */
const toTitleCase = (text: string): string => {
  if (!text) return text;
  
  const minorWords = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', 'if', 'in', 'of', 'on', 'or', 'the', 'to', 'up'];
  
  return text.toLowerCase().split(' ').map((word, index) => {
    // Always capitalize first and last word, and words not in minor words list
    if (index === 0 || !minorWords.includes(word)) {
      return word.charAt(0).toUpperCase() + word.slice(1);
    }
    return word;
  }).join(' ');
};

/**
 * Validate citation format
 */
export const validateCitation = (citation: string, style: CitationStyle): boolean => {
  if (!citation || citation.trim().length === 0) return false;
  
  switch (style) {
    case 'apa':
      // Basic APA validation: should have year in parentheses
      return /\(\d{4}\)/.test(citation) || /\(n\.d\.\)/.test(citation);
    case 'mla':
      // Basic MLA validation: should have quoted title
      return /"[^"]+"/g.test(citation);
    case 'chicago':
      // Basic Chicago validation: should have year and quoted title
      return /\d{4}/.test(citation) && /"[^"]+"/g.test(citation);
    default:
      return true;
  }
};