import { Paper } from '../types';

export type CitationStyle = 'apa' | 'mla' | 'chicago';

export interface FormattedCitation {
  citation: string;
  style: CitationStyle;
  paper: Paper;
}

/**
 * Generate a formatted citation for a single paper
 */
export const formatCitation = (paper: Paper, style: CitationStyle): string => {
  switch (style) {
    case 'apa':
      return formatAPA(paper);
    case 'mla':
      return formatMLA(paper);
    case 'chicago':
      return formatChicago(paper);
    default:
      return formatAPA(paper);
  }
};

/**
 * Generate multiple citations for papers
 */
export const formatCitations = (papers: Paper[], style: CitationStyle): FormattedCitation[] => {
  return papers.map(paper => ({
    citation: formatCitation(paper, style),
    style,
    paper
  }));
};

/**
 * Export citations as formatted text
 */
export const exportCitations = (papers: Paper[], style: CitationStyle, collectionName?: string): string => {
  const citations = formatCitations(papers, style);
  const styleNames = {
    apa: 'APA (7th Edition)',
    mla: 'MLA (9th Edition)', 
    chicago: 'Chicago (17th Edition)'
  };

  const header = collectionName 
    ? `# ${collectionName} - ${styleNames[style]} Citations\n\n`
    : `# ${styleNames[style]} Citations\n\n`;

  const citationList = citations.map((item, index) => 
    `${index + 1}. ${item.citation}`
  ).join('\n\n');

  const footer = `\n\n---\n*Generated by OpenScholar on ${new Date().toLocaleDateString()}*\n*${papers.length} citations in ${styleNames[style]} format*`;

  return header + citationList + footer;
};

/**
 * Format citation in APA style (7th edition)
 */
const formatAPA = (paper: Paper): string => {
  const authors = formatAuthorsAPA(paper.authors);
  const year = paper.year ? `(${paper.year})` : '(n.d.)';
  const title = paper.title.endsWith('.') ? paper.title : `${paper.title}.`;
  
  let citation = `${authors} ${year}. ${title}`;
  
  if (paper.journal) {
    citation += ` *${paper.journal}*.`;
  }
  
  if (paper.doi) {
    citation += ` https://doi.org/${paper.doi}`;
  } else if (paper.full_text_url) {
    citation += ` ${paper.full_text_url}`;
  }
  
  return citation;
};

/**
 * Format citation in MLA style (9th edition)
 */
const formatMLA = (paper: Paper): string => {
  const authors = formatAuthorsMLA(paper.authors);
  const title = `"${paper.title.replace(/\.$/, '')}"`;
  
  let citation = `${authors}. ${title}`;
  
  if (paper.journal) {
    citation += ` *${paper.journal}*,`;
  }
  
  if (paper.year) {
    citation += ` ${paper.year},`;
  }
  
  if (paper.doi) {
    citation += ` doi:${paper.doi}.`;
  } else if (paper.full_text_url) {
    const domain = extractDomain(paper.full_text_url);
    citation += ` *${domain}*, ${paper.full_text_url}.`;
  } else {
    citation = citation.replace(/,$/, '.');
  }
  
  return citation;
};

/**
 * Format citation in Chicago style (17th edition, Author-Date)
 */
const formatChicago = (paper: Paper): string => {
  const authors = formatAuthorsChicago(paper.authors);
  const year = paper.year || 'n.d.';
  const title = `"${paper.title.replace(/\.$/, '')}"`;
  
  let citation = `${authors}. ${year}. ${title}.`;
  
  if (paper.journal) {
    citation += ` *${paper.journal}*.`;
  }
  
  if (paper.doi) {
    citation += ` https://doi.org/${paper.doi}.`;
  } else if (paper.full_text_url) {
    citation += ` ${paper.full_text_url}.`;
  }
  
  return citation;
};

/**
 * Format authors for APA style
 */
const formatAuthorsAPA = (authors: string[]): string => {
  if (authors.length === 0) return '[No author]';
  if (authors.length === 1) return formatAuthorLastFirst(authors[0]);
  if (authors.length === 2) {
    return `${formatAuthorLastFirst(authors[0])}, & ${formatAuthorLastFirst(authors[1])}`;
  }
  if (authors.length <= 20) {
    const formatted = authors.slice(0, -1).map(formatAuthorLastFirst).join(', ');
    return `${formatted}, & ${formatAuthorLastFirst(authors[authors.length - 1])}`;
  }
  // 21+ authors: first 19, then "...", then last author
  const first19 = authors.slice(0, 19).map(formatAuthorLastFirst).join(', ');
  return `${first19}, ... ${formatAuthorLastFirst(authors[authors.length - 1])}`;
};

/**
 * Format authors for MLA style
 */
const formatAuthorsMLA = (authors: string[]): string => {
  if (authors.length === 0) return '[No author]';
  if (authors.length === 1) return formatAuthorLastFirst(authors[0]);
  if (authors.length === 2) {
    return `${formatAuthorLastFirst(authors[0])}, and ${formatAuthorFirstLast(authors[1])}`;
  }
  if (authors.length === 3) {
    return `${formatAuthorLastFirst(authors[0])}, ${formatAuthorFirstLast(authors[1])}, and ${formatAuthorFirstLast(authors[2])}`;
  }
  // 4+ authors: first author only, then "et al."
  return `${formatAuthorLastFirst(authors[0])}, et al.`;
};

/**
 * Format authors for Chicago style
 */
const formatAuthorsChicago = (authors: string[]): string => {
  if (authors.length === 0) return '[No author]';
  if (authors.length === 1) return formatAuthorLastFirst(authors[0]);
  if (authors.length === 2) {
    return `${formatAuthorLastFirst(authors[0])}, and ${formatAuthorFirstLast(authors[1])}`;
  }
  if (authors.length === 3) {
    return `${formatAuthorLastFirst(authors[0])}, ${formatAuthorFirstLast(authors[1])}, and ${formatAuthorFirstLast(authors[2])}`;
  }
  if (authors.length <= 10) {
    const allButLast = authors.slice(0, -1).map((author, index) => 
      index === 0 ? formatAuthorLastFirst(author) : formatAuthorFirstLast(author)
    ).join(', ');
    return `${allButLast}, and ${formatAuthorFirstLast(authors[authors.length - 1])}`;
  }
  // 11+ authors: first 7, then "et al."
  const first7 = authors.slice(0, 7).map((author, index) => 
    index === 0 ? formatAuthorLastFirst(author) : formatAuthorFirstLast(author)
  ).join(', ');
  return `${first7}, et al.`;
};

/**
 * Format author name as "Last, First Middle"
 */
const formatAuthorLastFirst = (author: string): string => {
  const cleaned = author.trim().replace(/,$/, '');
  
  // If already in "Last, First" format, return as-is
  if (cleaned.includes(',')) {
    return cleaned;
  }
  
  // Split by spaces and assume last word is surname
  const parts = cleaned.split(' ');
  if (parts.length === 1) return parts[0];
  
  const lastName = parts[parts.length - 1];
  const firstNames = parts.slice(0, -1).join(' ');
  
  return `${lastName}, ${firstNames}`;
};

/**
 * Format author name as "First Middle Last"
 */
const formatAuthorFirstLast = (author: string): string => {
  const cleaned = author.trim().replace(/,$/, '');
  
  // If in "Last, First" format, convert to "First Last"
  if (cleaned.includes(',')) {
    const [lastName, firstNames] = cleaned.split(',').map(part => part.trim());
    return `${firstNames} ${lastName}`;
  }
  
  // Already in "First Last" format
  return cleaned;
};

/**
 * Extract domain from URL for MLA citations
 */
const extractDomain = (url: string): string => {
  try {
    const domain = new URL(url).hostname.replace('www.', '');
    // Capitalize first letter
    return domain.charAt(0).toUpperCase() + domain.slice(1);
  } catch {
    return 'Web';
  }
};

/**
 * Get citation style display names
 */
export const getCitationStyleName = (style: CitationStyle): string => {
  const names = {
    apa: 'APA (7th Edition)',
    mla: 'MLA (9th Edition)',
    chicago: 'Chicago (17th Edition)'
  };
  return names[style];
};

/**
 * Validate citation format
 */
export const validateCitation = (citation: string, style: CitationStyle): boolean => {
  if (!citation || citation.trim().length === 0) return false;
  
  switch (style) {
    case 'apa':
      // Basic APA validation: should have year in parentheses
      return /\(\d{4}\)/.test(citation) || /\(n\.d\.\)/.test(citation);
    case 'mla':
      // Basic MLA validation: should have quoted title
      return /"[^"]+"/g.test(citation);
    case 'chicago':
      // Basic Chicago validation: should have year and quoted title
      return /\d{4}/.test(citation) && /"[^"]+"/g.test(citation);
    default:
      return true;
  }
};